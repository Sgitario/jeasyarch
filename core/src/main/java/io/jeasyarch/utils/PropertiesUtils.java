package io.jeasyarch.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Properties;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.lang3.StringUtils;

public final class PropertiesUtils {
    public static final String SLASH = "/";
    public static final String RESOURCE_PREFIX = "resource::/";
    public static final String SECRET_PREFIX = "secret::/";

    private static final String AUTOGENERATED_COMMENT = "# This properties file has been auto generated by JEasyArch";
    private static final String PROPERTY_START_TAG = "${";
    private static final String PROPERTY_END_TAG = "}";
    private static final String PROPERTY_WITH_OPTIONAL = ":";

    private PropertiesUtils() {

    }

    public static Optional<List<String>> getAsList(Map<String, String> properties, String property) {
        return get(properties, property).filter(StringUtils::isNotEmpty)
                .map(value -> Stream.of(value.split(",")).collect(Collectors.toList()));
    }

    public static Optional<Duration> getAsDuration(Map<String, String> properties, String property) {
        return get(properties, property).filter(StringUtils::isNotEmpty).map(DurationUtils::parse);
    }

    public static Optional<Double> getAsDouble(Map<String, String> properties, String property) {
        return get(properties, property).filter(StringUtils::isNotEmpty).map(Double::parseDouble);
    }

    public static Optional<Boolean> getAsBoolean(Map<String, String> properties, String property) {
        return get(properties, property).map(Boolean::parseBoolean);
    }

    public static Optional<String> get(Map<String, String> properties, String property) {
        return Optional.ofNullable(properties.get(property));
    }

    public static String[] resolveProperties(String[] values) {
        if (values == null || values.length == 0) {
            return values;
        }

        String[] newValues = Arrays.copyOf(values, values.length);
        for (int index = 0; index < values.length; index++) {
            newValues[index] = resolveProperty(newValues[index]);
        }

        return newValues;
    }

    /**
     * Try to resolve the value property from the value if the content is contained between ${xxx}.
     *
     * @param value
     *
     * @return
     */
    public static String resolveProperty(String value) {
        if (StringUtils.startsWith(value, PROPERTY_START_TAG)) {
            String propertyKey = StringUtils.substringBetween(value, PROPERTY_START_TAG, PROPERTY_END_TAG);
            String defaultValue = StringUtils.EMPTY;
            int optionalIndex = propertyKey.indexOf(PROPERTY_WITH_OPTIONAL);
            if (optionalIndex > 0) {
                defaultValue = propertyKey.substring(optionalIndex + 1);
                propertyKey = propertyKey.substring(0, optionalIndex);
            }

            return System.getProperty(propertyKey, defaultValue);
        }

        return value;
    }

    public static void fromMap(Map<String, String> map, Path target) {
        Properties properties = new Properties();
        properties.putAll(map);
        try (PrintWriter pw = new PrintWriter(target.toFile())) {
            pw.println(AUTOGENERATED_COMMENT);
            for (Map.Entry<Object, Object> e : properties.entrySet()) {
                pw.println(e.getKey() + "=" + e.getValue());
            }
        } catch (Exception e) {
            throw new RuntimeException("Could not create file in target", e);
        }
    }

    public static Map<String, String> toMap(String propertiesFile) {
        try (InputStream in = ClassLoader.getSystemResourceAsStream(propertiesFile)) {
            return toMap(in);
        } catch (IOException e) {
            throw new RuntimeException("Could not load map from system resource", e);
        }
    }

    public static Map<String, String> toMap(Path path) {
        try (InputStream in = Files.newInputStream(path)) {
            return toMap(in);
        } catch (IOException e) {
            throw new RuntimeException("Could not load map from path", e);
        }
    }

    public static Map<String, String> toMap(InputStream is) {
        Properties properties = new Properties();
        try {
            properties.load(is);
        } catch (IOException e) {
            throw new RuntimeException("Could not load map", e);
        }

        return (Map) properties;
    }

}
